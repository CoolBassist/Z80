              	; --------------------------------------
              	; zasm: assemble "Collatz.asm"
              	; date: 2024-03-31 12:40:18
              	; --------------------------------------


              	; Program for printing out the collatz sequence for a given number.
              	; Written by github.com/coolbassist
              	; Program for outputting text from a keyboard
              	; Written by github.com/coolbassist
              	
              	
              	; Memory map
              	; ADDR  | Function
              	; ------|---------
              	; 8000h | Temporary location for the A register (outputchar)
              	; 8001h | Number of characters on current line
              	; 8002h | Temporary location for H
              	; 8003h | Temporary location for L
              	; 8004h | Current line number (0 or 1)
              	; 8005h | Temporary location for the A register (outputnum)
              	; 8006h | Write pointer for CB
              	; 8007h | Read pointer for CB
              	;    ....
              	; 8010h | Begin circular buffer
              	;    ....
              	; 804Fh | End circular buffer
              	
0002:         	LCDCOM      equ 2     ; For sending a command to the LCD
0003:         	LCDCHR      equ 3     ; For sending a character to the LCD
              	
8000:         	T_A_C       equ 8000h ; Temporary A for char
8001:         	NO_CHR      equ 8001h ; no of characters on the line
8002:         	T_HL        equ 8002h ; temporary HL
              	
8004:         	CUR_LINE    equ 8004h ; Current line number
8005:         	T_A_N       equ 8005h ; temporary A for num
8006:         	CB_WR       equ 8006h ; Circular Buffer write 
8007:         	CB_RD       equ 8007h ; Circular Buffer read
8008:         	HAS_START   equ 8008h ; Has the program started?
0010:         	CB_ST       equ 10h   ; Circular Buffer start
004F:         	CB_END      equ 4Fh   ; Circular Buffer end
              	
0000:         		org 0
              	
              	    ; Setting up the LCD display
              	
0000: 3E38    		LD    A, 38H      ; function set.
0002: D302    		OUT   LCDCOM, A
              	
0004: 3E0F    		LD    A, 0FH      ; display on
0006: D302    		OUT   LCDCOM, A
              	
0008: 3E01    		LD    A, 01H      ; clear display
000A: D302    		OUT   LCDCOM, A
              	
000C: 3E06    		LD    A, 06H      ; entry mode
000E: D302    		OUT   LCDCOM, A
              	
              	    ; Display set up is now finished
              	
0010: 31FF80  		LD    SP, 80FFH   ; Setting stackpointer to highest point in RAM
              	
0013: 3E00    		LD    A, 0
0015: 320180  		LD    (NO_CHR), A  ; Number of characters on the current line
0018: 320480  		LD    (CUR_LINE), A  ; Current line
              	
001B: 3E10    	      LD    A, CB_ST
001D: 320680  	      LD    (CB_WR), A ; Write pointer for CB
0020: 320780  	      LD    (CB_RD), A ; Read pointer for CB
              	
0023: FB      		EI                ; enable interrupts
              	
0024: ED56    		IM    1           ; interrupt mode 1
              	
0026: 210880  	      LD    HL, HAS_START
0029: 3600    	      LD    (HL), 0
              	
002B: C35600  		JP    start
              	
002E: FFFFFFFF		org   38h ; begin interupt sequence
0032: FF...   	
              	
0038: F3      		DI      ; Disable interrupts
              	
0039: 08      		EX    AF, AF'  ; Save the current register state
003A: D9      		EXX
              	
003B: DB00    		IN    A, 0h         ; get user input
003D: 210680  	      LD    HL, CB_WR     ; load read pointer into HL
0040: 6E      	      LD    L, (HL)       ; deferencing pointer
0041: 77      	      LD    (HL), A       ; Load the user input into the read pointer
0042: 210680  	      LD    HL, CB_WR
0045: 34      	      INC   (HL)          ; increment read pointer
0046: 7E      	      LD    A, (HL)
0047: 064F    	      LD    B, CB_END
0049: B8      	      CP    B
004A: C25200  	      JP    NZ, intreturn
004D: 3E10    	      LD    A, CB_ST
004F: 320680  	      LD    (CB_WR), A
              	
0052:         	intreturn:
0052: D9      		EXX
0053: 08      		EX    AF, AF'
0054: FB      		EI
0055: C9      		RET
              	
0056:         	start:
0056: 210680  	      LD    HL, CB_WR
0059: 7E      	      LD    A, (HL)    ; loads the write pointer into A
005A: 23      	      INC   HL         
005B: 46      	      LD    B, (HL)    ; loads the read pointer into B
005C: B8      	      CP    B          ; If the read and write pointers are equal, theres nothing to do.
005D: CA5600  	      JP    Z, start
              	      ; checking for special keys
0060: 3A0780  	      LD    A, (CB_RD)
0063: 6F      	      LD    L, A
0064: 7E      	      LD    A, (HL)
0065: FE7F    	      CP    127                ; is a backspace?
0067: CA3A01  	      JP    Z, backspace       ; yes it is, go to backspace subroutine
006A: FE0D    	      CP    13                 ; is it an enter? To start the program
006C: CA8B00  	      JP    Z, startprogram    ; yes it is, start the program
              	      ; check for backspace,
              	      ; and other keys here
006F: 210780  	      LD    HL, CB_RD      ; Load read pointer into HL
0072: 6E      	      LD    L, (HL)        ; dereferencing pointer
0073: 7E      	      LD    A, (HL)        ; load the value at RP into A
0074: CDEE00  	      CALL  outputchar     ; output value.
0077: 210780  	      LD    HL, CB_RD
007A: 34      	      INC   (HL)           ; increment the RP
007B: 7E      	      LD    A, (HL)           ; load the inc RP into mem
007C: 064F    	      LD    B, CB_END         ; 
007E: B8      	      CP    B              ; is it at the end of the CB?
007F: C25600  	      JP    NZ, start      ; if not go back.
0082: 3E10    	      LD    A, CB_ST         
0084: 320780  	      LD    (CB_RD), A     ; if so, reset the read pointer
              	    
0087: C35600  	      JP    start
              	
008A: 76      		HALT    ; Program should never get here.
              	
008B:         	startprogram:
008B: 210880  	      LD    HL, HAS_START
008E: 7E      	      LD    A, (HL)
008F: FE01    	      CP    1
0091: CAC700  	      JP    Z, startcollatz
0094: 2680    	      LD    H, 80h
0096: 2E10    	      LD    L, CB_ST
0098: 7E      	      LD    A, (HL)
0099: D630    	      SUB   30h
              	
009B: 21B001  	      LD    HL, atn     ; loading the start of array into HL
009E: 85      	      ADD   A, L        ; indexing the array
009F: 6F      	      LD    L, A        ; loading the new index into L
00A0: 7E      	      LD    A, (HL)     ; loading the element into A
              	
00A1: CB17    	      RL    A
00A3: 57      	      LD    D, A
00A4: CB17    	      RL    A
00A6: CB17    	      RL    A
00A8: 82      	      ADD   D
              	
00A9: 4F      	      LD    C, A        ; Store it in C
              	
00AA: 2680    	      LD    H, 80h
00AC: 2E10    	      LD    L, CB_ST
00AE: 23      	      INC   HL
00AF: 7E      	      LD    A, (HL)
00B0: D630    	      SUB   30h
              	
              	
00B2: 21B001  	      LD    HL, atn     ; loading the start of array into HL
00B5: 85      	      ADD   A, L        ; indexing the array
00B6: 6F      	      LD    L, A        ; loading the new index into L
00B7: 7E      	      LD    A, (HL)     ; loading the element into A
              	
00B8: 81      	      ADD   C           ; The two bytes combined into one number
00B9: 57      	      LD    D, A  
              	
00BA: 210880  	      LD    HL, HAS_START
00BD: 3601    	      LD    (HL), 1h
              	
00BF: 3E0D    	      LD    A,    13
00C1: CDEE00  	      CALL  outputchar
00C4: CDEE00  	      CALL  outputchar
              	
00C7:         	startcollatz:
00C7: 210680  	      LD    HL, CB_WR   ; \
00CA: 35      	      DEC   (HL)        ; / decrement value held at the write pointer
00CB: 7A      	      LD    A, D
00CC: CD7301  	      CALL  outputnumber
00CF: CB47    	      BIT   0, A
00D1: CAE100  	      JP    Z, evenroutine
              	      ; its odd
00D4: 4F      	      LD    C, A
00D5: 87      	      ADD   A, A
00D6: 81      	      ADD   A, C  ; 3n
00D7: 3C      	      INC   A     ; +1
00D8: 57      	      LD    D, A
00D9: 3E20    	      LD    A, ' '
00DB: CDEE00  	      CALL  outputchar
00DE: C35600  	      JP    start
00E1:         	evenroutine:
00E1: CB1F    	      RR    A     ; n/2
00E3: E67F    	      AND   7Fh
00E5: 57      	      LD    D, A
00E6: 3E20    	      LD    A, ' '
00E8: CDEE00  	      CALL  outputchar
00EB: C35600  	      JP    start
              	
00EE:         	outputchar:
00EE: 220280  	      LD    (T_HL), HL ; Stores HL into a temporary location
00F1: 320080  	      LD    (T_A_C), A  ; Stores A  into a temporary location
              	
              	
              	    ; Do we need to go onto a new line?
              	
00F4: 210180  	      LD    HL, NO_CHR
00F7: 7E      	      LD    A, (HL)
00F8: FE10    	      CP    A, 16       ; Is the current number of characters equal to 16?
00FA: CC0501  	      CALL  Z, lb       ; If so, put a line break
              	      
              	
              	
00FD: 3A0080  	      LD    A,  (T_A_C) ; restores A
0100: FE0D    	      CP    A,  13      ; Is the current character a line break?
0102: C21E01  	      JP    nz, nonlb   ; If not, continue to the non line break section
0105:         	lb:
0105: 210480  	      LD    HL, CUR_LINE   
0108: 7E      	      LD    A, (HL)     
0109: FE01    	      CP    A, 1              ; Are we currently on the second line?
010B: CA2B01  	      JP    Z, clearscreen    ; If so, clear the screen
010E: 3EA8    	      LD    A, 0A8h           ; A is equal to 40, the location of the second line
0110: D302    	      OUT   LCDCOM, A         ; Puts the cursor on the second line
0112: 210180  	      LD    HL, NO_CHR   
0115: 3600    	      LD    (HL), 0           ; sets the current number of characters to 0
0117: 210480  	      LD    HL, CUR_LINE   
011A: 34      	      INC   (HL)              ; increments the current line number
011B: C32401  	      JP    charcleanup
011E:         	nonlb:
011E: 210180  	      LD    HL, NO_CHR      ; Number of characters variable
0121: 34      	      INC   (HL)           ; Plus one
0122: D303    	      OUT   LCDCHR, A
0124:         	charcleanup:
0124: 2A0280  	      LD    HL, (T_HL)    ; restores HL
0127: 3A0080  	      LD    A, (T_A_C)     ; restores A
012A: C9      	      RET
012B:         	clearscreen:
012B: 3E01    	      LD    A, 01h
012D: D302    	      OUT   LCDCOM, A
012F: 210480  	      LD    HL, CUR_LINE
0132: 3600    	      LD    (HL), 0        ; resets the line number
0134: 210180  	      LD    HL, NO_CHR   
0137: 3600    	      LD    (HL), 0        ; sets the current number of characters to 0
              	
0139: C9      	      RET                  ; returns back to the call in outputchar
              	
013A:         	backspace:
013A: 210680  	      LD    HL, CB_WR   ; \
013D: 35      	      DEC   (HL)        ; / decrement value held at the write pointer
013E: 3A0180  	      LD    A, (NO_CHR)  ; 
0141: FE00    	      CP    0
0143: CA5600  	      JP    Z, start    ; are we on the far left? If so, just go back.
0146: 3D      	      DEC   A
0147: 320180  	      LD    (NO_CHR), A
014A: 3A0480  	      LD    A, (CUR_LINE)
014D: 0601    	      LD    B, 1
014F: B8      	      CP    B        ; are we on the second line?
0150: 3A0180  	      LD    A, (NO_CHR)
0153: C25801  	      JP    NZ, backspaceend ; if not just jump to end
0156: C640    	      ADD   A, 40h
              	
0158:         	backspaceend:
0158: F680    	      OR    80h
015A: 47      	      LD    B, A
015B: D302    	      OUT   LCDCOM, A
015D: 3E20    	      LD    A, ' '
015F: D303    	      OUT   LCDCHR, A
0161: 78      	      LD    A, B
0162: D302    	      OUT   LCDCOM, A
0164: C35600  	      JP    start
              	    
0167:         	outputstring:
0167: 7E      	      LD    A, (HL)
0168: CDEE00  	      CALL  outputchar
016B: 23      	      INC   HL
016C: 7E      	      LD    A, (HL)
016D: FE00    	      CP    A, 0
016F: C26701  	      JP    NZ, outputstring
0172: C9      	      RET
              	
0173:         	outputnumber:
0173: 320580  	      LD   (T_A_N), A   ; temporarily store A at memory location 8005
              	
              	    ; most significant digit
              	
0176: CB1F    	      RR    A           ; \ 
0178: CB1F    	      RR    A           ; | Moving left most bits to the right
017A: CB1F    	      RR    A           ; |
017C: CB1F    	      RR    A           ; /
              	
              	
017E: E60F    	      AND   0Fh         ; A is now within the range 0-F
0180: FE00    	      CP    A, 0        ; Is A 0?
0182: CA8E01  	      JP    z, LSD      ; If so, dont bother printing leading digit
              	                        ; Else, continue printing leading digit
              	
0185: 21A001  	      LD    HL, characters ; loading the start of array into HL
0188: 85      	      ADD   A, L           ; indexing the array
0189: 6F      	      LD    L, A           ; loading the new index into L
018A: 7E      	      LD    A, (HL)        ; loading the element into A 
018B: CDEE00  	      CALL  outputchar     ; output digit
              	
              	    ; least significant digit
018E:         	LSD:
018E: 3A0580  	      LD    A, (T_A_N)     ; setting A back to original
0191: E60F    	      AND   0Fh            ; A is now within the range 0-F
0193: 21A001  	      LD    HL, characters ; loading the start of array into HL
0196: 85      	      ADD   A, L           ; indexing the array
0197: 6F      	      LD    L, A           ; loading the new index into L
0198: 7E      	      LD    A, (HL)        ; loading the element into A 
0199: CDEE00  	      CALL  outputchar     ; output digit
              	      ; cleaning up after ourselves
019C: 3A0580  	      LD    A, (T_A_N)     ; put the original value of A back into A.
019F: C9      	      RET ; returning
              	
01A0: 30313233	characters: .ascii "0123456789ABCDEF"
01A4: 34353637	
01A8: 38394142	
01AC: 43444546	
              	
01B0: 00010203	atn: .ascii 000102030405060708092020202020200A0B0C0D0E0Fh
01B4: 04050607	
01B8: 08092020	
01BC: 20202020	
01C0: 0A0B0C0D	
01C4: 0E0F    	


; +++ segments +++

#CODE          = $0000 =     0,  size = $01C6 =   454

; +++ global symbols +++

CB_END       = $004F =    79          Collatz.asm:36
CB_RD        = $8007 = 32775          Collatz.asm:33
CB_ST        = $0010 =    16          Collatz.asm:35
CB_WR        = $8006 = 32774          Collatz.asm:32
CUR_LINE     = $8004 = 32772          Collatz.asm:30
HAS_START    = $8008 = 32776          Collatz.asm:34
LCDCHR       = $0003 =     3          Collatz.asm:24
LCDCOM       = $0002 =     2          Collatz.asm:23
LSD          = $018E =   398          Collatz.asm:308
NO_CHR       = $8001 = 32769          Collatz.asm:27
T_A_C        = $8000 = 32768          Collatz.asm:26
T_A_N        = $8005 = 32773          Collatz.asm:31
T_HL         = $8002 = 32770          Collatz.asm:28
_end         = $01C6 =   454          Collatz.asm:38 (unused)
_size        = $01C6 =   454          Collatz.asm:38 (unused)
atn          = $01B0 =   432          Collatz.asm:322
backspace    = $013A =   314          Collatz.asm:251
backspaceend = $0158 =   344          Collatz.asm:266
characters   = $01A0 =   416          Collatz.asm:320
charcleanup  = $0124 =   292          Collatz.asm:237
clearscreen  = $012B =   299          Collatz.asm:241
evenroutine  = $00E1 =   225          Collatz.asm:196
intreturn    = $0052 =    82          Collatz.asm:95
lb           = $0105 =   261          Collatz.asm:221
nonlb        = $011E =   286          Collatz.asm:233
outputchar   = $00EE =   238          Collatz.asm:204
outputnumber = $0173 =   371          Collatz.asm:285
outputstring = $0167 =   359          Collatz.asm:276
start        = $0056 =    86          Collatz.asm:101
startcollatz = $00C7 =   199          Collatz.asm:180
startprogram = $008B =   139          Collatz.asm:135


total time: 0.0058 sec.
no errors
