              	; --------------------------------------
              	; zasm: assemble "collatz_better.asm"
              	; date: 2023-12-14 13:30:17
              	; --------------------------------------


              	; Library for outputting to an LCD screen
              	; Written by github.com/coolbassist
              	
              	
0002:         	LCDCOM  equ 2     ; For sending a command to the LCD
0003:         	LCDCHR  equ 3     ; For sending a character to the LCD
              	
0000:         	      org 0
              	
              	      ; Setting up the LCD display
              	
0000: 3E38    	      LD    A, 38H      ; function set.
0002: D302    	      OUT   LCDCOM, A
              	
0004: 3E0C    	      LD    A, 0CH      ; display on
0006: D302    	      OUT   LCDCOM, A
              	
0008: 3E01    	      LD    A, 01H      ; clear display
000A: D302    	      OUT   LCDCOM, A
              	
000C: 3E06    	      LD    A, 06H      ; entry mode
000E: D302    	      OUT   LCDCOM, A
              	
              	      ; Display set up is now finished
              	
              	
              	
0010: 31FF80  	      LD   SP, 80FFH   ; Setting stackpointer to highest point in RAM
              	
0013: 3E00    	      LD   A, 0
0015: 320180  	      LD   (8001h), A  ; Number of characters current displayed
0018: 320480  	      LD   (8004h), A  ; Current line
              	
              	
              	
001B: FB      	      EI                ; enable interrupts
              	
001C: ED56    	      IM    1           ; interrupt mode 1
              	
001E: 211801  	      LD    HL, enternum
0021: CDCF00  	      CALL  outputstring
              	
              	
              	
0024: C35000  	      JP    start
              	
0027: FFFFFFFF	      org 38h ; begin interupt sequence
002B: FF...   	
              	
0038: F3      	      DI
              	
0039: 08      	      EX    AF, AF'
003A: D9      	      EXX
              	      
              	      
003B: DB00    	      IN    A, 0h
              	
003D: 210680  	      LD    HL,   8006h
0040: 77      	      LD    (HL), A
              	
0041: 3E0A    	      LD    A, 0Ah
0043: CD8300  	      CALL  outputchar
0046: CD8300  	      CALL  outputchar
              	      
0049: D9      	      EXX
004A: 08      	      EX    AF, AF'
              	
004B: FB      	      EI
              	
004C: CD5300  	      CALL performcollatz
              	
004F: C9      	      RET
              	      
              	
0050:         	start:
0050: C35000  	      JP    start
              	
0053:         	performcollatz:
0053: 210680  	      LD    HL, 8006h
0056: 7E      	      LD    A,  (HL)    ; loads user input into A
0057: CDDB00  	      CALL  outputnumber
              	
005A: FE01    	      CP    1           ; is A one?
005C: C26000  	      JP    nz, cont    ; if not, continue with the sequence.
005F: C9      	      RET
              	
0060:         	cont: 
0060: CB47    	      BIT   0, A        ; else is A even?
0062: CA7000  	      JP    z, even     ; yes it is. Perform even routine
0065: 47      	      LD   B, A         ; \ No it isnt, perform odd routine
0066: 87      	      ADD  A, A         ; | 3n
0067: 80      	      ADD  A, B         ; |
0068: 3C      	      INC  A            ; / +1
0069: 210680  	      LD   HL, 8006h
006C: 77      	      LD   (HL), A      ; store new A in 8006h
006D: C37600  	      JP   end
              	
0070:         	even:
0070: CB1F    	      RR   A            ; Divide A by 2
0072: 210680  	      LD   HL, 8006h
0075: 77      	      LD   (HL), A      ; store new A in 8006h
              	
0076:         	end:
0076: 3E2C    	      LD   A, ','
0078: CD8300  	      CALL outputchar
007B: 3E20    	      LD   A, ' '
007D: CD8300  	      CALL outputchar
0080: C35300  	      JP   performcollatz   ; Jump back to the beginning
              	
              	
              	
              	
0083:         	outputchar:
0083: 220280  	      LD    (8002h), HL ; Stores HL into a temporary location
0086: 320080  	      LD    (8000h), A  ; Stores A  into a temporary location
              	
              	
              	      ; Do we need to go onto a new line?
              	
0089: 210180  	      LD    HL, 8001h
008C: 7E      	      LD    A, (HL)
008D: FE10    	      CP    A, 16       ; Is the current number of characters equal to 16?
008F: CC9A00  	      CALL  Z, lb       ; If so, put a line break
              	      
              	
              	
0092: 3A0080  	      LD    A,  (8000h) ; restores A
0095: FE0A    	      CP    A,  0Ah     ; Is the current character a line break?
0097: C2B300  	      JP    nz, nonlb   ; If not, continue to the non line break section
009A:         	lb:
009A: 210480  	      LD    HL, 8004h   
009D: 7E      	      LD    A, (HL)     
009E: FE01    	      CP    A, 1              ; Are we currently on the second line?
00A0: CAC000  	      JP    Z, clearscreen    ; If so, clear the screen
00A3: 3EA8    	      LD    A, 0A8h           ; A is equal to 40, the location of the second line
00A5: D302    	      OUT   LCDCOM, A         ; Puts the cursor on the second line
00A7: 210180  	      LD    HL, 8001h   
00AA: 3600    	      LD    (HL), 0           ; sets the current number of characters to 0
00AC: 210480  	      LD    HL, 8004h   
00AF: 34      	      INC   (HL)              ; increments the current line number
00B0: C3B900  	      JP    charcleanup
00B3:         	nonlb:
00B3: 210180  	      LD    HL, 8001h      ; Number of characters variable
00B6: 34      	      INC   (HL)           ; Plus one
00B7: D303    	      OUT   LCDCHR, A
00B9:         	charcleanup:
00B9: 2A0280  	      LD    HL, (8002h)    ; restores HL
00BC: 3A0080  	      LD    A, (8000h)     ; restores A
00BF: C9      	      RET
00C0:         	clearscreen:
00C0: 3E01    	      LD    A, 01h
00C2: D302    	      OUT   LCDCOM, A
00C4: 210480  	      LD    HL, 8004h
00C7: 3600    	      LD    (HL), 0        ; resets the line number
00C9: 210180  	      LD    HL, 8001h   
00CC: 3600    	      LD    (HL), 0        ; sets the current number of characters to 0
              	
00CE: C9      	      RET                  ; returns back to the call in outputchar
              	
00CF:         	outputstring:
00CF: 7E      	      LD    A, (HL)
00D0: CD8300  	      CALL  outputchar
00D3: 23      	      INC   HL
00D4: 7E      	      LD    A, (HL)
00D5: FE00    	      CP    A, 0
00D7: C2CF00  	      JP    NZ, outputstring
00DA: C9      	      RET
              	
00DB:         	outputnumber:
00DB: 320580  	      LD   (8005h), A   ; temporarily store A at memory location 8000
              	
              	    ; most significant digit
              	
00DE: CB1F    	      RR    A           ; \ 
00E0: CB1F    	      RR    A           ; | Moving left most bits to the right
00E2: CB1F    	      RR    A           ; |
00E4: CB1F    	      RR    A           ; /
              	
              	
00E6: E60F    	      AND   0Fh         ; A is now within the range 0-F
00E8: FE00    	      CP    A, 0        ; Is A 0?
00EA: CAF600  	      JP    z, LSD      ; If so, dont bother printing leading digit
              	                        ; Else, continue printing leading digit
              	
00ED: 210801  	      LD    HL, characters ; loading the start of array into HL
00F0: 85      	      ADD   A, L           ; indexing the array
00F1: 6F      	      LD    L, A           ; loading the new index into L
00F2: 7E      	      LD    A, (HL)        ; loading the element into A 
00F3: CD8300  	      CALL  outputchar     ; output digit
              	
              	    ; least significant digit
00F6:         	LSD:
00F6: 3A0580  	      LD    A, (8005h)     ; setting A back to original
              	
00F9: E60F    	      AND   0Fh            ; A is now within the range 0-F
              	
              	    
00FB: 210801  	      LD    HL, characters ; loading the start of array into HL
00FE: 85      	      ADD   A, L           ; indexing the array
00FF: 6F      	      LD    L, A           ; loading the new index into L
0100: 7E      	      LD    A, (HL)        ; loading the element into A 
0101: CD8300  	      CALL  outputchar     ; output digit
              	
              	    ; cleaning up after ourselves
              	
0104: 3A0580  	      LD    A, (8005h)     ; put the original value of A back into A.
              	
              	    ; returning
              	
0107: C9      	      RET
              	
0108: 30313233	characters: .ascii "0123456789ABCDEF"
010C: 34353637	
0110: 38394142	
0114: 43444546	
              	
0118: 456E7465	enternum: .ascii "Enter number!", 0
011C: 72206E75	
0120: 6D626572	
0124: 2100    	


; +++ segments +++

#CODE          = $0000 =     0,  size = $0126 =   294

; +++ global symbols +++

LCDCHR         = $0003 =     3          collatz_better.asm:6
LCDCOM         = $0002 =     2          collatz_better.asm:5
LSD            = $00F6 =   246          collatz_better.asm:191
_end           = $0126 =   294          collatz_better.asm:8 (unused)
_size          = $0126 =   294          collatz_better.asm:8 (unused)
characters     = $0108 =   264          collatz_better.asm:211
charcleanup    = $00B9 =   185          collatz_better.asm:145
clearscreen    = $00C0 =   192          collatz_better.asm:149
cont           = $0060 =    96          collatz_better.asm:86
end            = $0076 =   118          collatz_better.asm:102
enternum       = $0118 =   280          collatz_better.asm:213
even           = $0070 =   112          collatz_better.asm:97
lb             = $009A =   154          collatz_better.asm:129
nonlb          = $00B3 =   179          collatz_better.asm:141
outputchar     = $0083 =   131          collatz_better.asm:112
outputnumber   = $00DB =   219          collatz_better.asm:168
outputstring   = $00CF =   207          collatz_better.asm:159
performcollatz = $0053 =    83          collatz_better.asm:77
start          = $0050 =    80          collatz_better.asm:74


total time: 0.0082 sec.
no errors
